<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Play With Code on</title><link>https://roamnote.com/play-with-code/</link><description>Recent content in Play With Code on</description><generator>Hugo -- gohugo.io</generator><language>zh</language><atom:link href="https://roamnote.com/play-with-code/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://roamnote.com/play-with-code/caddy-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%A4%87%E4%BB%BD/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://roamnote.com/play-with-code/caddy-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%A4%87%E4%BB%BD/</guid><description>2023-10-21晚，在研究如何使用 caddy 通过 cloudflare api 新增 DNS 记录，也是折腾了好久。
用到的资料：
caddy 第三方 ddns 插件： https://github.com/mholt/caddy-dynamicdns ，使用这个插件的时候，需要把这个插件编译到 caddy 二进制文件中，todo：当时是怎么编译的
caddy 官方文档： https://caddyserver.com/docs/caddyfile/directives/tls#examples ，解释了如何使用 cloudflare 申请 tls 证书
配置文件做个备份：
# 这个模块是用来动态更新域名解析的，其中的 token 是 dns edit token { dynamic_dns { provider cloudflare A9ko3agcDBZhdRTATQMdJDyAw5B3D3lToim70BS0JB domains { # 这里至少需要写一个 域名 和 子域名， # 并且子域名必须是下面显示声明的 # 之后 dynamic_dns 会去寻找别的为罗列在此的域名 example1.com hello # 同上 example1.com hello } ip_source simple_http https://ip.3322.net dynamic_domains check_interval 1m } log { output file /var/log/caddy/access.</description></item><item><title/><link>https://roamnote.com/play-with-code/chmod-%E9%80%9F%E6%9F%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://roamnote.com/play-with-code/chmod-%E9%80%9F%E6%9F%A5/</guid><description>chmod 命令用于修改文件或目录的权限，其主要参数包括：
u：表示 &amp;ldquo;user&amp;rdquo;，即文件或目录的所有者。 g：表示 &amp;ldquo;group&amp;rdquo;，即文件或目录的所属组。 o：表示 &amp;ldquo;others&amp;rdquo;，即其他用户。 a：表示 &amp;ldquo;all&amp;rdquo;，即所有用户（包括所有者、所属组和其他用户）。 每个参数可以与 +（增加权限）、-（移除权限）或 =（设置权限）结合使用。权限的类型主要有：
r：表示 &amp;ldquo;read&amp;rdquo;，即读取权限。 w：表示 &amp;ldquo;write&amp;rdquo;，即写入权限。 x：表示 &amp;ldquo;execute&amp;rdquo;，即执行权限。 可以组合出各种 chmod 命令来设置文件或目录的权限。以下是一些示例：
chmod u+x file：给文件所有者增加执行权限。 chmod u-x file：从文件所有者处移除执行权限。 chmod u=rwx file：设置文件所有者的权限为读、写、执行。 chmod g+w file：给文件所属组增加写入权限。 chmod o-r file：从其他用户处移除读取权限。 chmod a+r file：给所有用户增加读取权限。 此外，chmod 还支持使用数字来设置权限，其中 4 表示读取权限，2 表示写入权限，1 表示执行权限。这些数字可以相加，所以可以使用 chmod 755 file 来设置文件所有者的权限为读、写、执行（7 = 4+2+1），并设置文件所属组和其他用户的权限为读、执行（5 = 4+1）。</description></item><item><title/><link>https://roamnote.com/play-with-code/git-auto-push-for-macos/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://roamnote.com/play-with-code/git-auto-push-for-macos/</guid><description>之前在 pc 上使用 logseq，期间写了一篇博文 git-auto-push for windows，阐述了我如何利用 git 来备份笔记。近来主力机从 pc 变成了 macbook，同样面临着笔记备份的问题。所幸问题得以解决，记录此文，以便查阅。
现在logseq已经内置git版本控制，这篇文章的内容可能没有帮助了。
![[20220410182228.png]]
gitMac 上自带 git，不需要额外安装，运行 which git 可以查看 git 的路径，这个路径一会要用。
![[20210427190721.png]]
利用 launchd 创建守护进程launchd 可以为创建守护进程。
打开 ~/Library/LaunchAgents(LaunchAgents 中的配置会在用户登录时被执行)，新建一个文件，名字随意，例如git-auto-push.plist，写入一下内容：
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;!DOCTYPE plist PUBLIC &amp;#34;-//Apple//DTD PLIST 1.0//EN&amp;#34; &amp;#34;http://www.apple.com/DTDs/PropertyList-1.0.dtd&amp;#34;&amp;gt; &amp;lt;plist version=&amp;#34;1.0&amp;#34;&amp;gt; &amp;lt;dict&amp;gt; &amp;lt;key&amp;gt;KeepAlive&amp;lt;/key&amp;gt; &amp;lt;true/&amp;gt; &amp;lt;key&amp;gt;Label&amp;lt;/key&amp;gt; &amp;lt;string&amp;gt;git-auto-push&amp;lt;/string&amp;gt; &amp;lt;!-- 标识，保持唯一即可 --&amp;gt; &amp;lt;key&amp;gt;ProgramArguments&amp;lt;/key&amp;gt; &amp;lt;array&amp;gt; &amp;lt;string&amp;gt;/usr/bin/git&amp;lt;/string&amp;gt; &amp;lt;!-- git 的路径，上一步查看到的路径 --&amp;gt; &amp;lt;string&amp;gt;acp&amp;lt;/string&amp;gt; &amp;lt;!-- 一个自定义的 git 的命令 --&amp;gt; &amp;lt;/array&amp;gt; &amp;lt;key&amp;gt;WorkingDirectory&amp;lt;/key&amp;gt; &amp;lt;string&amp;gt;/XXX/XXX/notes&amp;lt;/string&amp;gt; &amp;lt;!-- 工作路径，设置为笔记的路径 --&amp;gt; &amp;lt;key&amp;gt;RunAtLoad&amp;lt;/key&amp;gt; &amp;lt;!</description></item><item><title/><link>https://roamnote.com/play-with-code/git-auto-push-for-windows/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://roamnote.com/play-with-code/git-auto-push-for-windows/</guid><description>logseq 官方维护了一个 git-auto，有丰富的配置，开箱即用。而我这个则比较简陋，不支持丰富配置，但是比较容易看懂。如果不需要复杂的功能，我这个办法也挺香的。
现在logseq已经内置git版本控制，这篇文章的内容可能没有帮助了。
![[20220410182228.png]]
安装git首先需要在电脑上安装好 git，下载地址。
然后在安装目录里找到 git.exe 文件。如图：
![[20210228183844.png]]
右键查看其属性，找到其路径备用。如图：
![[20210228185509.png]]
bat脚本在任意位置新建一个文件 AutoPush.bat，名字也是任意的，写入以下内容：
@echo off @REM 进入到项目目录 cd &amp;#34;C:\xxx\xxx&amp;#34; @REM git 目录 set GIT_PATH=&amp;#34;D:\App\Git\cmd\git.exe&amp;#34; @REM 设置分支 set BRANCH = &amp;#34;origin&amp;#34; @REM 循环标记 :loop @REM add 命令 %GIT_PATH% add -A @REM commit 命令 %GIT_PATH% commit -m &amp;#34;auto commit&amp;#34; @REM pull 命令，如果不需要每次 push 之前都 pull ，可以把这个删除 %GIT_PATH% pull %BRANCH% @REM push 命令 %GIT_PATH% push %BRANCH% @REM 等待 180 秒 timeout 180 &amp;gt; NUL @REM 回到 loop 标记处 goto loop 至此，这个文件已经可以使用了，双击即可使用。如果想在后台自动运行，可以继续往下看。</description></item><item><title/><link>https://roamnote.com/play-with-code/linux/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://roamnote.com/play-with-code/linux/</guid><description>权限
[[chmod 速查]]</description></item><item><title/><link>https://roamnote.com/play-with-code/paypal-webhook-%E4%BA%8B%E4%BB%B6%E5%BC%82%E6%AD%A5%E9%80%9A%E7%9F%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://roamnote.com/play-with-code/paypal-webhook-%E4%BA%8B%E4%BB%B6%E5%BC%82%E6%AD%A5%E9%80%9A%E7%9F%A5/</guid><description>另一个文章 https://www.bahjeez.com/validating-paypal-webhooks-offline-almost/ ，阐述了如何实现
PayPal WebHook即 paypal 异步通知功能，订阅了相应的事件后，当发生了订阅的事件，paypal 会 post 一个 json 格式的数据到所配置的地址上。
配置WebHook地址和订阅事件https://developer.paypal.com/developer/applications
选择查看应用详情后拉到最下面的Webhook配置，输入通知地址和订阅事件，点击保存后，会生成一个Webhook ID（在验证Webhook信息的时候用到）。
checkout order相关的事件：https://developer.paypal.com/docs/checkout/apm/reference/subscribe-to-webhooks/
所有事件：https://developer.paypal.com/api/rest/webhooks/event-names/
需要响应200状态码表示处理成功，否则会在3天内最多发送10次。
Webhook事件 CHECKOUT.ORDER.APPROVED：客户授权支付，此时可收款。 PAYMENT.CAPTURE.COMPLETED：收款完成，即交易完成。 PAYMENT.CAPTURE.PENDING：交易需要审核。 PAYMENT.CAPTURE.DENIED：拒绝了收款。 PAYMENT.CAPTURE.REFUNDED：退款。 CUSTOMER.DISPUTE.CREATED：客户发起争议，此时也会收到RISK.DISPUTE.CREATED消息，内容一致。 CUSTOMER.DISPUTE.RESOLVED：争议解决。 接收并验证Webhook消息为了保证webhook消息的真实性，需要对消息进行验证，避免处理假消息。参考文档地址：https://developer.paypal.com/api/rest/webhooks/
需要用到的header:
PAYPAL-TRANSMISSION-ID: Http 传输的唯一ID PAYPAL-TRANSMISSION-TIME：时间 PAYPAL-CERT-URL：Public key 地址 PAYPAL-TRANSMISSION-SIG：签名 PAYPAL-AUTH-ALGO：签名算法 验证方式一：调接口获取webhook详情通过Webhook的消息ID调用接口去获取webhook消息详情
GET https://api.paypal.com/v1/notifications/webhooks-events/{EVENT_ID}
验证方式二：调用验签API调用paypal的验签API
POST https://api.paypal.com/v1/notifications/verify-webhook-signature
参数{ /** * 签名方式，可从header信息的PAYPAL-AUTH-ALGO获取 */ &amp;#34;auth_algo&amp;#34;: string; /** * 公钥地址，可从header信息的PAYPAL-CERT-URL获取 */ &amp;#34;cert_url&amp;#34;: string; /** * HTTP传输ID，可从header信息的PAYPAL-TRANSMISSION-ID获取 */ &amp;#34;transmission_id&amp;#34;: string; /** * 签名，可从header信息的PAYPAL-TRANSMISSION-SIG获取 */ &amp;#34;transmission_sig&amp;#34;: string; /** * 时间，可从header信息的PAYPAL-TRANSMISSION-TIME获取 */ &amp;#34;transmission_time&amp;#34;: string; /** * Webhook ID，即webhook配置的ID */ &amp;#34;webhook_id&amp;#34;: string; /** * webhook事件 */ &amp;#34;webhook_event&amp;#34;: string; } 响应{ /** * 验证结果 * SUCCESS - 成功 * FAILURE - 失败 */ &amp;#34;verification_status&amp;#34;: string; } 验证方式三：自己手动验证验证签名，输入的字符串为：</description></item><item><title/><link>https://roamnote.com/play-with-code/php-%E5%AE%89%E8%A3%85-xdebug-%E5%B0%8F%E8%AE%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://roamnote.com/play-with-code/php-%E5%AE%89%E8%A3%85-xdebug-%E5%B0%8F%E8%AE%B0/</guid><description>官方文档：https://xdebug.org/docs/install#pecl
os version：
![[20221123113342.png]]
php version:
PHP 7.4.32 (cli) (built: Sep 29 2022 10:45:51) ( NTS ) Copyright (c) The PHP Group Zend Engine v3.4.0, Copyright (c) Zend Technologies with Zend OPcache v7.4.32, Copyright (c), by Zend Technologies homebrew version:
Homebrew 3.6.10 Homebrew/homebrew-core (git revision 98c836067d9; last commit 2022-11-09) Homebrew/homebrew-cask (git revision 4e901c025d; last commit 2022-11-10) pecl path:
/opt/homebrew/Cellar/php@7.4/7.4.32/bin/pecl pecl extension directory:
执行 pecl config-get ext_dir
/opt/homebrew/lib/php/pecl/20190902 这里需要先确认该目录是否存在，如果不存在会导致 Xdebug 安装失败，就需要手动创建。执行 mkdir -p /opt/homebrew/lib/php/pecl/20190902 即可。</description></item><item><title/><link>https://roamnote.com/play-with-code/php/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://roamnote.com/play-with-code/php/</guid><description>原生 php
[[php 安装 Xdebug 小记]] [[利用 PHP 的反射机制实现依赖注入]] [[如何查看 php fpm 监听的是 UNIX sock 还是 TCP]] [[PayPal WebHook 事件异步通知]] laravel
[[在 Laravel 中 PayPal Webhook 签名验证失败]]</description></item><item><title/><link>https://roamnote.com/play-with-code/python-%E6%90%AD%E9%85%8D-automator-%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%88%B0-github/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://roamnote.com/play-with-code/python-%E6%90%AD%E9%85%8D-automator-%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%88%B0-github/</guid><description>自从写博客以来，一直有上传图片的需求，一开始用第三方图床，例如微博等等，其缺点是图片不属于自己，某一天可能就无法访问了。后来也折腾过腾讯、阿里的对象存储。直到后来发现可以把文件存在 github 上，再配合 jsdelivr 的 CDN，在国内访问速度也挺快。
至于上传图片的工具，用过 iPic、uPic、picGo，其中 iPic 是付费的，他们的好处是支持不同的图床、配置方便、不需要折腾。
本着断舍离的原则，我写了一个 Python 脚本，配合系统自带的 Automator ，实现了把文件夹里的文件（含图片）、微信群里的图片或者剪切板的图片上传到 github，如果开了&amp;quot;接力&amp;quot;功能，也可以上传在手机里复制图片。
效果![[20220916010307.gif]]
Python 脚本在电脑上新建一个 Python 文件，例如upload-file.py，把下面的内容复制进去。
import io import os import re import json import time import base64 import requests import subprocess from urllib import parse # Pillow from PIL import Image, ImageGrab # PyObjC from AppKit import NSPasteboard, NSURLPboardType # 从剪切板获取完整的文件路径 def getPath(): # https://developer.apple.com/documentation/appkit/nspasteboard/pasteboardtype pb = NSPasteboard.generalPasteboard() url = pb.stringForType_(NSURLPboardType) if url is None: return None else: plistBytes = url.</description></item><item><title/><link>https://roamnote.com/play-with-code/%E4%BD%BF%E7%94%A8-fusejs-%E7%BB%99-hugo-%E5%8D%9A%E5%AE%A2%E5%A2%9E%E5%8A%A0%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://roamnote.com/play-with-code/%E4%BD%BF%E7%94%A8-fusejs-%E7%BB%99-hugo-%E5%8D%9A%E5%AE%A2%E5%A2%9E%E5%8A%A0%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/</guid><description>搜索方案概述搜索方案大体上分为前端搜索和后端搜索。
后端搜索通常使用 elastic search，这是一个很成熟的解决方案。另外，使用 rust 编写的 meili search 也是一个很好的选择。最后，不同的语言通常会有一些小众化的解决方案，例如 php 中的 tnt search，以及迅搜。
后端搜索还可以使用第三方的服务，algolia 就是一个不错的选择，有免费额度，个人用户可以考虑。再者就是使用各大云厂商提供的搜索服务。
前端搜索也可以叫做 browser search 或者 offline search，总的来说就是搜索的时候不需要发请求到服务器。关于前端搜索，我所了解的，有这么几个可供选择：
lunrjs - js 写的一个搜索库 elasticlunr - 基于 lunrjs 开发的另一个方案 fusejs - js 写的一个搜索库，官方口号是 Fuse.js is a powerful, lightweight fuzzy-search library, with zero dependencies. 这个网站还有列举了另外几个不是很流行的库。
总体上说，前端方案是轻量级的，而后端方案成熟、大而全。下面介绍 fusejs 方案。
基本用法&amp;lt;script&amp;gt; // 数据 const data = [ { &amp;#34;title&amp;#34;: &amp;#34;hello world&amp;#34;, }, { &amp;#34;title&amp;#34;: &amp;#34;你好，世界&amp;#34;, } ]; // 弄一个实例 const fuse = new Fuse(data, { // 自定义需要搜索的字段 keys: [&amp;#34;title&amp;#34;] }); // 执行搜索 const result = fuse.</description></item><item><title/><link>https://roamnote.com/play-with-code/%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%90%8C%E7%9A%84-ssh-key-%E7%AE%A1%E7%90%86%E4%B8%8D%E5%90%8C%E7%9A%84-github-%E8%B4%A6%E6%88%B7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://roamnote.com/play-with-code/%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%90%8C%E7%9A%84-ssh-key-%E7%AE%A1%E7%90%86%E4%B8%8D%E5%90%8C%E7%9A%84-github-%E8%B4%A6%E6%88%B7/</guid><description>生成不同的 ssh 密钥对使用命令 ssh-keygen -t ed25519 -C 'xx01@xxx.com' 可以生成密钥对。这里的 -t ed25519 指明了使用 ed25519 公钥加密算法。生成的过程中，系统会提示输入文件需要保存的路径，如果不输入，默认为：~/.ssh/id_ed25519 和 ~/.ssh/id_ed25519.pub。
假设有两个 github 账户需要管理，用户名分别是：
cat dog 使用上述命令分别生成两个密钥对：
~/.ssh/id_ed25519_cat 和 ~/.ssh/id_ed25519_cat.pub ~/.ssh/id_ed25519_dog 和 ~/.ssh/id_ed25519_dog.pub 自定义域名别名与私钥的对应关系打开 ~/.ssh/config 文件，没有则新建一个。填入以下内容：
Host github.com-cat HostName github.com User git IdentityFile ~/.ssh/id_ed25519_cat Host github.com-dog HostName github.com User git IdentityFile ~/.ssh/id_ed25519_cat 这里配置了两个域名别名，分别是 github.com-cat 和 github.com-dog，它们的真实域名都是指向 github.com，但是它们使用了不同的私钥。
配置 fetch url 和 push url简略的说，设置远程 url 的时候，把其中的 git@github.com 替换为 git@github.com-cat 或者 git@github.com-dog 即可，ssh 就会去 ~/.ssh/config 文件中找对应的密钥。</description></item><item><title/><link>https://roamnote.com/play-with-code/%E5%88%A9%E7%94%A8-php-%E7%9A%84%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://roamnote.com/play-with-code/%E5%88%A9%E7%94%A8-php-%E7%9A%84%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/</guid><description>认识ReflectionClass类该类实现了Reflector接口，可以使用该类查看另一个类的相关信息。所谓的反射，大概的意思就是将一个类的相关信息给反射（映射、反映）出来。
定义两个类以供测试。
完整的代码附在后面。
&amp;lt;?php namespace Models; class Car { protected $engine; //引擎 public static $name = &amp;#39;卡丁车&amp;#39;; //车名 public static $model; //型号 public $price = 200000; //售价 public $color = &amp;#39;red&amp;#39;; //颜色 const WIDTH = 2; //车宽 const HEIGHT = 1.5; //车高 public function __construct(Engine $engine) { $this-&amp;gt;engine = $engine; } /** * 开车 * * @return void */ public function drive() { } //给汽车加油 public static function fuel() { } } class Engine { public function __construce() { } } $reflector = new \ReflectionClass(new Car(new Engine())); 属性相关的方法//获取一个属性，类似的有getProperties()，获取一组属性 $price = $reflector-&amp;gt;getProperty(&amp;#39;price&amp;#39;); var_dump($price); //获取属性默认值 $defaultProperties = $reflector-&amp;gt;getDefaultProperties(); var_dump($defaultProperties); //检测是否含有某个属性 $result = $reflector-&amp;gt;hasProperty(&amp;#39;price&amp;#39;); var_dump($result); !</description></item><item><title/><link>https://roamnote.com/play-with-code/%E5%9C%A8-docker-%E4%B8%AD%E7%A6%81%E7%94%A8-opensearch-%E7%9A%84%E5%AE%89%E5%85%A8%E6%8F%92%E4%BB%B6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://roamnote.com/play-with-code/%E5%9C%A8-docker-%E4%B8%AD%E7%A6%81%E7%94%A8-opensearch-%E7%9A%84%E5%AE%89%E5%85%A8%E6%8F%92%E4%BB%B6/</guid><description>相关连接： https://opensearch.org/docs/latest/security/configuration/disable/
使用 docker ps 找到当前运行的 container 的 id，假设是 657ba743c58d 使用 docker exec -u0 -it 657ba743c58d /bin/bash 登录到容器内部 找到 opensearch 的配置文件，通常是在 /usr/share/opensearch/config/opensearch.yml，参考 https://opensearch.org/docs/latest/install-and-configure/configuring-opensearch/index/#configuration-file 然后使用 /usr/share/opensearch/config/opensearch.yml 编辑该文件，把 plugins.security.disabled: true 放到配置文件末尾，保存文件。 如果在编辑文件的时候，提示没有安装 vim，可以使用 yum install -y vim 安装一下 vim 使用 docker restart 657ba743c58d 重启容器</description></item><item><title/><link>https://roamnote.com/play-with-code/%E5%9C%A8-laravel-%E4%B8%AD-paypal-webhook-%E7%AD%BE%E5%90%8D%E9%AA%8C%E8%AF%81%E5%A4%B1%E8%B4%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://roamnote.com/play-with-code/%E5%9C%A8-laravel-%E4%B8%AD-paypal-webhook-%E7%AD%BE%E5%90%8D%E9%AA%8C%E8%AF%81%E5%A4%B1%E8%B4%A5/</guid><description>背景最近在工作中需要把集成 PayPal 到系统里。大体流程是：客户在网页上发起付款，跳转到 paypal 页面，客户付款之后，需要去确认用户是否付款成功。 PayPal 提供了 webhook，给调用者发送事件，例如：当客户点了付款的 button，PayPal 会发送 CHECKOUT.ORDER.APPROVED 事件给调用者。当 order 被捕获，付款完成之后，Paypal 会发送PAYMENT.CAPTURE.COMPLETED事件给调用者。
由于提供给 PayPal 调用的 API 是公开的，当这个 API 被调用的时候，提供方就需要确认这个请求是否是 PayPal 官方发起的，也就是所谓的验证签名。PayPal 提供了验证签名的 API，需要按照它的要求，组装好数据，发送给 PayPal。
问题组装好的数据，发送给 PayPal 之后，如果这个请求确实是 PayPal 发起的，它会返回 {&amp;quot;verification_status&amp;quot;:&amp;quot;SUCCESS&amp;quot;}，否则会返回 {&amp;quot;verification_status&amp;quot;:&amp;quot;FAILURE&amp;quot;}
我所遇到的问题是，有些签名是 SUCCESS，但是有些签名是 FAILURE，这就很奇怪。经过了对比实验，发现了问题所在。
错误的数据{ &amp;#34;webhook_id&amp;#34;: &amp;#34;{{webhook_id}}&amp;#34;, &amp;#34;transmission_id&amp;#34;: &amp;#34;{{event_transmission_id}}&amp;#34;, &amp;#34;transmission_time&amp;#34;: &amp;#34;{{event_transmission_time}}&amp;#34;, &amp;#34;cert_url&amp;#34;: &amp;#34;{{event_cert_url}}&amp;#34;, &amp;#34;auth_algo&amp;#34;: &amp;#34;{{event_auth_algo}}&amp;#34;, &amp;#34;transmission_sig&amp;#34;: &amp;#34;{{event_transmission_sig}}&amp;#34;, &amp;#34;webhook_event&amp;#34;: { &amp;#34;id&amp;#34;: &amp;#34;xxx&amp;#34;, &amp;#34;event_version&amp;#34;: &amp;#34;1.0&amp;#34;, &amp;#34;create_time&amp;#34;: &amp;#34;2023-12-04T07:06:02.318Z&amp;#34;, &amp;#34;resource_type&amp;#34;: &amp;#34;checkout-order&amp;#34;, &amp;#34;resource_version&amp;#34;: &amp;#34;2.0&amp;#34;, &amp;#34;event_type&amp;#34;: &amp;#34;CHECKOUT.ORDER.APPROVED&amp;#34;, &amp;#34;summary&amp;#34;: &amp;#34;An order has been approved by buyer&amp;#34;, &amp;#34;resource&amp;#34;: { &amp;#34;create_time&amp;#34;: &amp;#34;2023-12-04T07:05:52Z&amp;#34;, &amp;#34;purchase_units&amp;#34;: [ { &amp;#34;reference_id&amp;#34;: &amp;#34;default&amp;#34;, &amp;#34;amount&amp;#34;: { &amp;#34;currency_code&amp;#34;: &amp;#34;AUD&amp;#34;, &amp;#34;value&amp;#34;: &amp;#34;0.</description></item><item><title/><link>https://roamnote.com/play-with-code/%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B-php-fpm-%E7%9B%91%E5%90%AC%E7%9A%84%E6%98%AF-unix-sock-%E8%BF%98%E6%98%AF-tcp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://roamnote.com/play-with-code/%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B-php-fpm-%E7%9B%91%E5%90%AC%E7%9A%84%E6%98%AF-unix-sock-%E8%BF%98%E6%98%AF-tcp/</guid><description> 使用命令 find / -name www.conf 找到配置文件，例如： /etc/php-fpm.d/www.conf 打开文件找到 listen = 127.0.0.1:9000 或者 listen = cat /var/run/php-fpm/php-fpm.sock，即可确认使用的是哪种方式 更改为需要的方式，执行 systemctl restart php-fpm 重启 php-fpm</description></item><item><title/><link>https://roamnote.com/play-with-code/%E5%AE%B6%E5%BA%AD%E5%AE%BD%E5%B8%A6%E7%8E%AF%E5%A2%83%E4%B8%8B%E4%BD%BF%E7%94%A8-caddy-%E5%8F%8D%E4%BB%A3%E5%86%85%E7%BD%91%E4%B8%AD%E7%9A%84%E6%9C%8D%E5%8A%A1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://roamnote.com/play-with-code/%E5%AE%B6%E5%BA%AD%E5%AE%BD%E5%B8%A6%E7%8E%AF%E5%A2%83%E4%B8%8B%E4%BD%BF%E7%94%A8-caddy-%E5%8F%8D%E4%BB%A3%E5%86%85%E7%BD%91%E4%B8%AD%E7%9A%84%E6%9C%8D%E5%8A%A1/</guid><description>在家庭宽带环境下，如果拥有一个公网 ip 地址，可以使用 caddy 反代内网中不同服务器上的服务，绑定不同的域名，并暴露在公网上。
问题情景假设内网里有两台服务器，ip 分别是 192.168.1.2 和 192.168.1.3。
192.168.1.2 上跑了一个服务：
https 服务，监听的端口是 443。这里的 https 服务，使用 caddy，其默认的端口是 443，参考： https://caddyserver.com/docs/caddyfile/options#https-port 192.168.1.3 上跑了两个服务：
movie 服务，监听的端口是 8001 music 服务，监听的端口是 8002 下载 caddy下载地址： https://caddyserver.com/download?package=github.com%2Fcaddy-dns%2Fcloudflare
选择合适的平台，顺便把 caddy-dns/cloudflare 勾选上。下载文件，并把二进制文件放到 192.168.1.2 服务器上。
![[2024012214590267.png]]
这里使用 caddy-dns/cloudflare 的原因是：我的域名是用 cloudflare 管理的。这个模块可以在 443 端口不可用的情况下，让 caddy 和 cloudflare 建立通信，从而自动申请 SSL 证书。参考： https://github.com/caddy-dns/cloudflare?tab=readme-ov-file 和 https://caddyserver.com/docs/automatic-https
如果使用别的 DNS 服务商，caddy 也提供了很多选择，参考： https://caddyserver.com/docs/modules/
![[2024012215390886.png]]
如果有其他的申请 SSL 证书的办法，可以忽略 caddy-dns module。
配置 Caddyfile打开默认的配置文件： /etc/caddy/Caddyfile，填入以下内容
(TLS) { tls { dns cloudflare tokenXX } } movie.</description></item><item><title/><link>https://roamnote.com/play-with-code/%E6%9C%89%E8%B6%A3%E7%9A%84%E9%A1%B9%E7%9B%AE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://roamnote.com/play-with-code/%E6%9C%89%E8%B6%A3%E7%9A%84%E9%A1%B9%E7%9B%AE/</guid><description>Pakehttps://github.com/tw93/Pake
利用 Rust 轻松构建轻量级多端桌面应用
归家出行https://www.home-coming.cn/
MAC 平台下的一个抢火车票的 APP
Locohttps://loco.rs/
Loco is a Web or API framework for Rust. It&amp;rsquo;s also a productivity suite for developers: it contains everything you need while building a hobby or your next startup. It&amp;rsquo;s also strongly inspired by Rails
Screen Studiohttps://www.screen.studio/
强大的录屏软件，价格 90 刀
Beautiful Screen Recordings in Minutes. Creating high quality videos as easy as taking a screenshot. Designed for macOS.
评论系统 artalkhttps://github.com/ArtalkJS/Artalk</description></item><item><title/><link>https://roamnote.com/play-with-code/%E7%94%B1%E4%BA%8E%E6%9D%83%E9%99%90%E4%B8%8D%E5%AF%B9%E5%AF%BC%E8%87%B4%E9%83%A8%E7%BD%B2-magento-%E5%A4%B1%E8%B4%A5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://roamnote.com/play-with-code/%E7%94%B1%E4%BA%8E%E6%9D%83%E9%99%90%E4%B8%8D%E5%AF%B9%E5%AF%BC%E8%87%B4%E9%83%A8%E7%BD%B2-magento-%E5%A4%B1%E8%B4%A5/</guid><description>问题重现 使用 root 身份登录服务器 git clone 拉取代码 composer install 安装包 安装 magento bin/magento setup:install \ --base-url=https://xx.xx.com \ --db-host=127.0.0.1:3308 \ --db-name=magento \ --db-user=root \ --db-password= \ --backend-frontname=admin \ --admin-firstname=admin \ --admin-lastname=admin \ --admin-email=admin@admin.com \ --admin-user=admin \ --admin-password=xx \ --language=en_US \ --currency=AUD \ --timezone=Australia/Melbourne \ --use-rewrites=1 \ --search-engine=opensearch \ --elasticsearch-host=localhost \ --elasticsearch-port=9200 \ --elasticsearch-index-prefix=magento \ --elasticsearch-timeout=15 执行 php bin/magento s:d:c 构建依赖 执行 php bin/magento s:up 更新软件 配置 /etc/caddy/Caddyfile xx.xx.com { root * /srv/magento/pub php_fastcgi 127.</description></item></channel></rss>