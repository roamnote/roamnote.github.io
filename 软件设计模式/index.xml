<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title/><link>https://roamnote.com/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link><description>Recent content on</description><generator>Hugo -- gohugo.io</generator><language>zh</language><atom:link href="https://roamnote.com/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://roamnote.com/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://roamnote.com/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</guid><description>工厂方法模式也会被简称为工厂模式，是[[简单工厂模式]]的升级版。那么，简单工厂模式存在什么问题呢？答案是违反了[[开闭原则|软件设计中的开闭原则]]
简单工厂模式存在什么问题思考一个问题：在简单工厂模式的基础上，如果现在需要新增加产品 C，需要怎么改代码？
新增 ConcreteProductC 类，实现 Product 更改 Creator 类中的 createProduct 类。 修改后的代码如下：
&amp;lt;?php class Creator { public function createProduct(string $type): Product { switch ($type) { case &amp;#39;A&amp;#39;: return new ConcreteProductA(); case &amp;#39;B&amp;#39;: return new ConcreteProductB(); case &amp;#39;C&amp;#39;: return new ConcreteProductC(); default: throw new Exception(&amp;#39;not found product&amp;#39;); } } } abstract class Product { } class ConcreteProductA extends Product { } class ConcreteProductB extends Product { } class ConcreteProductC extends Product { } $creator = new Creator(); $creator-&amp;gt;createProduct(&amp;#39;A&amp;#39;); 这不是挺好的吗，没啥问题。所以问题在哪？</description></item><item><title/><link>https://roamnote.com/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://roamnote.com/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</guid><description>在[[工厂方法模式]]中，当需要新增一个产品 C 的时候，只需要[[工厂方法模式#新增产品 C|两个步骤]]就满足需求。
所以是遇到什么问题了，需要把工厂方法升级为抽象工厂呢？
提出问题假设我是一个工厂的老板，工厂生产苹果手机的配件。例如：屏幕、电池。由于业务扩张，现在需要生产手机摄像头，此时参考工厂模式既可。
由于业务再次扩张，华为手机让我帮忙生产配件。此时我就要对配件进行分类，不能在笼统的成为：屏幕或者电池。
分类之后的配件：
苹果屏幕 苹果电池 华为屏幕 华为电池 按照工厂方法模式，该怎么办呢。按照产品类别分成两个体系既可：
屏幕体系 工厂 抽象屏幕工厂：ScreenCreator 苹果屏幕工厂：AppleScreenCreator 华为屏幕工厂：HuaWeiScreenCreator 产品 抽象屏幕：Screen 苹果屏幕：AppleScreen 华为屏幕：HuaWeiScreen 电池体系 工厂 抽象电池工厂：BatteryCreator 苹果电池工厂：AppleBatteryCreator 华为电池工厂：HuaWeiBatteryCreator 产品 抽象电池：Battery 苹果电池：AppleBattery 华为电池：HuaWeiBattery 此时，如果业务再次扩展，需要生产摄像头，需要做什么呢？新增一个摄像头体系既可：
摄像头体系 工厂 抽象摄像头工厂：CameraCreator 苹果摄像头工厂：AppleCameraCreator 华为摄像头工厂：HuaWeiCameraCreator 产品 抽象摄像头：Camera 苹果摄像头：AppleCamera 华为摄像头：HuaWeiCamera 此时，如果业务再次扩展，小米手机也来找我合作，需要做什么呢？在每个体系中增加小米的产品线既可。
屏幕体系 工厂 抽象屏幕工厂：ScreenCreator 苹果屏幕工厂：AppleScreenCreator 华为屏幕工厂：HuaWeiScreenCreator 小米屏幕工厂：XiaoMiScreenCreator &amp;lt;&amp;mdash;&amp;ndash;新增的 产品 抽象屏幕：Screen 苹果屏幕：AppleScreen 华为屏幕：HuaWeiScreen 小米屏幕：MiScreen &amp;lt;&amp;mdash;&amp;ndash;新增的 电池体系 工厂 抽象电池工厂：BatteryCreator 苹果电池工厂：AppleBatteryCreator 华为电池工厂：HuaWeiBatteryCreator 小米电池工厂：MiBatteryCreator &amp;lt;&amp;mdash;&amp;ndash;新增的 产品 抽象电池：Battery 苹果电池：AppleBattery 华为电池：HuaWeiBattery 小米电池：MiBattery &amp;lt;&amp;mdash;&amp;ndash;新增的 摄像头体系 工厂 抽象摄像头工厂：CameraCreator 苹果摄像头工厂：AppleCameraCreator 华为摄像头工厂：HuaWeiCameraCreator 小米摄像头工厂：MiCameraCreator &amp;lt;&amp;mdash;&amp;ndash;新增的 产品 抽象摄像头：Camera 苹果摄像头：AppleCamera 华为摄像头：HuaWeiCamera 小米摄像头：MiCamera &amp;lt;&amp;mdash;&amp;ndash;新增的 其实如果不嫌麻烦，这样一直搞下去也行。不就是一个笛卡尔积嘛，轻轻松松。</description></item><item><title/><link>https://roamnote.com/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://roamnote.com/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</guid><description>通常来说，不把简单工厂模式归纳在 23 种设计模式中。
&amp;lt;?php class Creator { public function createProduct(string $type): Product { switch ($type) { case &amp;#39;A&amp;#39;: return new ConcreteProductA(); case &amp;#39;B&amp;#39;: return new ConcreteProductB(); default: throw new Exception(&amp;#39;not found product&amp;#39;); } } } abstract class Product { } class ConcreteProductA extends Product { } class ConcreteProductB extends Product { } $creator = new Creator(); $creator-&amp;gt;createProduct(&amp;#39;A&amp;#39;); 上述的 Creator 是一个简单工厂，其中的 createProduct 函数，根据给定的 type 不同生产不同的产品。但是无论 type 是什么，得到的都是 Product 的子类。</description></item><item><title/><link>https://roamnote.com/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://roamnote.com/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/</guid><description>todo</description></item></channel></rss>